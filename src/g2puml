#Imports
import re
import yaml
import plantuml
import requests
from typing import List
from pathlib import Path
from gherkin.parser import Parser
from elop_tools import ElopConf
from abc import abstractmethod


RENDER_URL = 'http://www.plantuml.com/plantuml/img/'
class Model():

    skeleton = \
    """@startuml
    !theme plain

    header
        {header}
    end header

    legend top
        {legend}
    end legend

    'Entities

    box "Runners"
    {runners}
    end box

    box "Targets"
    {targets}
    end box

    box "Resources"
    {resources}
    end box

    'Sequence actions
    == Start Time ==

    {core}

    == End Time ==
    @enduml
    """

    def __init__(self,
                 elenv: ElopConf,
                 steps: List[dict],
                 img_name: str,
                 ) -> None:
        self._env = elenv
        self._steps = steps
        self._runners = None
        self._targets = None
        self._resources = None
        self._img_name = img_name.lower().replace(' ','_') + '.png'

    @abstractmethod
    def _get_puml_runners(self):
        pass

    @abstractmethod
    def _get_puml_targets(self):
        pass

    @abstractmethod
    def _get_puml_resources(self):
        pass

    @abstractmethod
    def _get_puml_header(self):
        pass

    @abstractmethod
    def _get_puml_legend(self):
        pass

    @abstractmethod
    def _get_core(self):
        pass

    def _get_plant_uml(self) -> str:
        return self.skeleton.format(
            header = self._get_puml_header(),
            legend = self._get_puml_legend(),
            runners = self._get_puml_runners(),
            targets = self._get_puml_targets(),
            resources = self._get_puml_resources(),
            core = self._get_puml_core(),
        )
    
    def export_puml(self) -> None:
        puml = plantuml.PlantUML(url=RENDER_URL)
        a = self._get_plant_uml()
        img_url = puml.get_url(a)
        img_data = requests.get(img_url).content
        with open(self._img_name, 'wb') as handler:
            handler.write(img_data)

class AD_Model(Model):

    header = \
    """
    \t|<b>Color| <#cyan> | <#gold> |
    \t|<b>Description| SWIFC Get | SWIFC Set |
    """

    get_sk = \
    """
    {csw1} --> {csw2} ++ #cyan: Get Request
    {sgn} o-> {csw2}:  Signal retrieved
    return Get Response
    """
    set_sk = \
    """
    {csw1} --> {csw1} ++ #gold: Set Request
    {csw1} ->o {sgn} --: Set Signal
    """

    open_task = \
        """autonumber {label}
            [x-> q: {task} Start
        autonumber stop
        
        """
    

    act_sk = "activate {x}"
    deact_sk = "deactivate {x}"

    queue_sk = '\tqueue "{runner}" as {n}\n'
    participant_sk = '\tparticipant "{swc}" as {n}\n'
    entity_sk = '\tentity "{sgn}" as {n}\n'

    def __init__(self,
                 *args,
                 **kwargs
                 ) -> None:
        super().__init__(*args,**kwargs)
        self.__set_core_attrs()

    def __get_alias(self, label: str):
        return label.lower().replace(' ','_')

    def __set_core_attrs(self):
        self._runners = []
        self._targets = {'active':[],'passive':[]}
        self._resources = []

        for x in self._steps:
            runx = x.get('runner')

            if runx:
                if runx not in self._runners:
                    self._runners.append(runx)

            swc = x.get('swc')
            if swc:
                if swc not in self._targets['active']:
                    self._targets['active'].append(swc)

            sgn = x.get('sgn')
            if sgn:
                if sgn not in self._resources:
                    self._resources.append(sgn)
                
                swc = self._env.get_swc_from_sgn(sgn)
                if swc not in self._targets['active'] and \
                    swc not in self._targets['passive']:
                    self._targets['passive'].append(swc)

    def _get_puml_runners(self) -> str:
        res = ''
        for v in self._runners:
            res += self.queue_sk.format(runner=v,n=self.__get_alias(v))

        return res

    def _get_puml_targets(self):
        res = ''
        for t in self._targets.values():
            for v in t:
                res += self.participant_sk.format(swc=v,n=self.__get_alias(v))

        return res

    def _get_puml_resources(self):
        res = ''
        for v in self._resources:
            res += self.entity_sk.format(sgn=v,n=self.__get_alias(v))

        return res

    def extract_core(self):
        '''Loop on the steps to extract the main puml strucutre'''

        core = []
        queue_name = self.__get_alias(self._runners[0])
        _last_task = {
            'name': None,
            'start': 0,
            'run_i': 0,
            'pos_i': 0,
        }
        _last_csw = None

        for x in self._steps:          
            kw = x.get('kw')
            swc = x.get('swc')
            sgn = x.get('sgn')
            run = x.get('runner')
            ssm = x.get('ssm')
            cmd = x.get('cmd')

            #Update last task
            if swc:
                c_task_name, c_task_run_i = self._env.get_task('opm',swc)
                if not (_last_task['run_i'] >= c_task_run_i):
                    _last_task['pos_i'] += 1
                
                a = self._env.get_task_scheduling(
                    task_name=c_task_name,
                    start_time=_last_task['start'],
                    start_pos=_last_task['pos_i']
                )

                if _last_task['name'] != c_task_name:
                    if not _last_task['name']:
                        lbl = "<b>[T01]"
                    else:
                        lbl = "resume"
                
                    core.append(self.open_task.format(label=lbl,task=c_task_name))
                    core.append(self.act_sk.format(x=queue_name))

                _last_task['name'] = c_task_name
                _last_task['start'] = a[0]
                _last_task['run_i'] = c_task_run_i
                _last_task['pos_i'] = a[1]

            #Check if the step opens an SWC operation
            if kw == 'When':
                if _last_csw != swc:
                    if _last_csw:
                        core.append(self.deact_sk.format(x=_last_csw))
                    core.append(self.act_sk.format(x=swc))
            
            if swc:
                _last_csw = swc

            if _last_csw:
                core.append(self.deact_sk.format(x=_last_csw))
            
        core.append(self.deact_sk.format(x=queue_name))

        print(core)


    def _get_puml_header(self):
        return self.header

    def _get_puml_legend(self):
        return ''

    def _get_puml_core(self):
        return ''

def get_existing_path(path: str) -> Path:
    p = Path(path)
    assert p.exists(), 'Error: %s does not exists!' % path
    return p

def get_map(path: str) -> dict:
    p = get_existing_path(path)
    p = yaml.safe_load(p.open('r'))

    #Compile rules
    for k, v in p['g2p'].items():
        t_v = []
        for rule in v:
            t_v.append(re.compile(rule))
        p['g2p'][k] = t_v
    
    return p

def get_parsed_step(step: str, rules: List[re.Pattern]) -> dict:
    '''Get the standard dictionary representation from a step text'''
    is_ok = False
    for r in rules:
        g = r.match(step)
        if g:
            is_ok = True
            break
    assert g, "Wrong step text syntax:\n\t%s\n\tCorrect syntax rule:\n\t%s" % (step, rules)
    return g.groupdict()

def get_collected_steps(scenario: dict, map: dict) -> List[dict]:
    last_keyword: str = None
    res: List[dict] = []

    for step in scenario['steps']:
        last_keyword =  last_keyword if step['keywordType'] == 'Conjunction' else \
            step['keyword'].replace(' ','')
        d = get_parsed_step(step['text'],map[last_keyword])
        d.update({'kw':last_keyword})
        res.append(d)

    return res

def main():
    root = Path(__file__).parents[1] 

    gd = Parser().parse("C:/Users/CMM2OFO/Documents/Repos/G2Puml/test_files/demo.feature")
    map = get_map('C:/Users/CMM2OFO/Documents/Repos/G2Puml/src/maps/ad_data_flow.yaml')

    out_f = gd['feature']['children'][0]['scenario']['name']

    elenv = ElopConf(icd_parh=root / "test_files" / 'icd.csv',
                     sch_path='C:/Users/CMM2OFO/Documents/Repos/G2Puml/Strategy2.yaml',
                     ssm_conf_path=root / "test_files" / 'ssm_conf.yaml',
                    )
    steps = get_collected_steps(gd['feature']['children'][0]['scenario'], map['g2p'])

    ad_model = AD_Model(elenv,steps,out_f)
    #ad_model.export_puml()
    ad_model.extract_core()

if __name__ == '__main__':
    main()