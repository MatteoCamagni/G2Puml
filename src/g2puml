#Imports
import re
import yaml
import plantuml
import requests
from typing import List
from pathlib import Path
from gherkin.parser import Parser
from elop_tools import ElopConf
from abc import abstractmethod


RENDER_URL = 'http://www.plantuml.com/plantuml/img/'

class TaskHandler():
    def __init__(self):
        self.prev_task = None
        self.order = 0
        self.start = 0
        self.cursor = 0
    
    def update_cursor(self) -> None:
        self.cursor += 1

    def update_task(self, new_tsk: str, new_order: int, new_start: int, new_cursor: str) -> None:
        self.prev_task = new_tsk
        self.order = new_order
        self.start = new_start
        self.cursor = new_cursor

class Model():

    skeleton = \
    """@startuml
    !theme plain

    title {title}

    header
        {header}
    end header

    legend top
        {legend}
    end legend

    'Entities

    box "Runners"
    {runners}
    end box

    box "Targets"
    {targets}
    end box

    box "Resources"
    {resources}
    end box

    'Sequence actions
    == Start Time ==

    {core}

    == End Time ==
    @enduml
    """

    def __init__(self,
                 elenv: ElopConf,
                 title: str,
                 steps: List[dict],
                 img_name: str,
                 ) -> None:
        self._env = elenv
        self._title = title
        self._steps = steps
        self._runners = None
        self._targets = None
        self._resources = None
        self._img_name = img_name.lower().replace(' ','_') + '.png'

    @abstractmethod
    def _get_puml_runners(self):
        pass

    @abstractmethod
    def _get_puml_targets(self):
        pass

    @abstractmethod
    def _get_puml_resources(self):
        pass

    @abstractmethod
    def _get_puml_header(self):
        pass

    @abstractmethod
    def _get_puml_legend(self):
        pass

    @abstractmethod
    def _get_core(self):
        pass

    def _get_plant_uml(self) -> str:
        core = self._get_puml_core()
        return self.skeleton.format(
            title = self._title,
            header = self._get_puml_header(),
            legend = self._get_puml_legend(),
            runners = self._get_puml_runners(),
            targets = self._get_puml_targets(),
            resources = self._get_puml_resources(),
            core = core,
        )
    
    def export_puml(self) -> None:
        puml = plantuml.PlantUML(url=RENDER_URL)
        a = self._get_plant_uml()
        img_url = puml.get_url(a)
        img_data = requests.get(img_url).content
        with open(self._img_name, 'wb') as handler:
            handler.write(img_data)
        with open("raw.puml", 'w') as handler:
            handler.write(a)

class AD_Model(Model):

    header = \
    """
    \t|<b>Color| <#cyan> | <#gold> |
    \t|<b>Description| SWIFC Get | SWIFC Set |
    """

    get_sk = \
    """
    {tab}{swc1} --> {swc2} ++ #cyan: Get Request
    {tab}{sgn} o-> {swc2}:  Signal retrieved
    {tab}return Get Response
    """
    set_sk = \
    """
    {tab}{swc1} --> {swc2} ++ #gold: Set Request
    {tab}{swc2} ->o {sgn} --: Set Signal
    """

    routine_sk = \
    """
    {tab}autonumber {timer}
    {tab}{q}-> {tgt}: {tgt_desc}
    {tab}autonumber stop\n
    """
    

    act_sk = "activate {x}\n"
    deact_sk = "deactivate {x}\n"

    queue_sk = '\tqueue "{runner}" as {n}\n'
    participant_sk = '\tparticipant "{swc}" as {n}\n'
    entity_sk = '\tentity "{sgn}" as {n}\n'

    def __init__(self,
                 *args,
                 **kwargs
                 ) -> None:
        super().__init__(*args,**kwargs)
        self.__set_core_attrs()
        self.__act_items = []
        self.__act_tabs = 0
        self._puml_timers = {}

    def __get_alias(self, label: str):
        return label.lower().replace(' ','_')

    def __set_core_attrs(self):
        self._runners = []
        self._targets = {'active':[],'passive':[]}
        self._resources = []

        for x in self._steps:
            runx = x.get('runner')

            if runx:
                if runx not in self._runners:
                    self._runners.append(runx)

            swc = x.get('swc')
            if swc:
                if swc not in self._targets['active']:
                    self._targets['active'].append(swc)

            sgn = x.get('sgn')
            if sgn:
                if sgn not in self._resources:
                    self._resources.append(sgn)
                
                swc = self._env.get_swc_from_sgn(sgn)
                if swc not in self._targets['active'] and \
                    swc not in self._targets['passive']:
                    self._targets['passive'].append(swc)

    def _get_puml_runners(self) -> str:
        res = ''
        for v in self._runners:
            res += self.queue_sk.format(runner=v,n=self.__get_alias(v))

        return res

    def _get_puml_targets(self):
        res = ''
        for t in self._targets.values():
            for v in t:
                res += self.participant_sk.format(swc=v,n=self.__get_alias(v))

        return res

    def _get_puml_resources(self):
        res = ''
        for v in self._resources:
            res += self.entity_sk.format(sgn=v,n=self.__get_alias(v))

        return res
    
    def _update_puml_timers(self, value, key: str= None):
        key = key if key!=None else f"T{len(self._puml_timers)}"
        self._puml_timers.update({key: value})

    def _get_puml_timer(self, runner: str, target: str, description: str, timer: str = "resume") -> str:
        return self.routine_sk.format(
            q = self.__get_alias(runner),
            tab = "\t" * self.__act_tabs,
            timer = timer,
            tgt = self.__get_alias(target),
            tgt_desc = description,
        )

    def _get_puml_new_task(self,task: str,  timer: str, runner: str) -> str:
        res = self._get_puml_timer(
            runner='[x', 
            target=runner, 
            description="Start "+task,
            timer=timer)
        res += self._get_puml_activation(item=runner, store=False)
        return res
    
    def _get_puml_end_task(self,task: str,  runner: str) -> str:
        res = self._get_puml_timer(
            runner='[x', 
            target=runner, 
            description="End "+task,
            timer="resume")
        res += self._get_puml_deactivation(item=runner, remove=False) 
        return res       
    
    def _get_puml_activation(self,item: str, store: bool = True) -> str:
        item = self.__get_alias(item)
        if store:
            self.__act_items.insert(0,item)
        self.__act_tabs += 1

        return "\t"*self.__act_tabs + self.act_sk.format(x= item)

    def _get_puml_deactivation(self,item: str, remove: bool = True) -> str:
        item = self.__get_alias(item)
        try:
            if remove:
                self.__act_items.remove(item)
            res = "\t"*self.__act_tabs + self.deact_sk.format(x=item)
            self.__act_tabs -= 1
        except:
            res = ""
        
        return res

    def _get_puml_deactivate_all(self) -> str:
        res = ""
        for item in self.__act_items:
            item = self.__get_alias(item)
            res += "\t"*self.__act_tabs + self.deact_sk.format(x=item) + "\n"
            self.__act_tabs -= 1

        self.__act_items = []
        self.__act_tabs = 0
        return res
    
    def _get_puml_read_sgn(self, swc1: str, swc2: str, sgn: str) -> str:
        swc1 = self.__get_alias(swc1)
        swc2 = self.__get_alias(swc2)
        sgn = self.__get_alias(sgn)
        return self.get_sk.format(tab="\t"*(self.__act_tabs+1), swc1=swc1, swc2=swc2, sgn=sgn)
    
    def _get_puml_write_sgn(self, swc1: str, swc2: str, sgn: str) -> str:
        swc1 = self.__get_alias(swc1)
        swc2 = self.__get_alias(swc2)
        sgn = self.__get_alias(sgn)
        return self.set_sk.format(tab="\t"*(self.__act_tabs+1), swc1=swc1, swc2=swc2, sgn=sgn)

    def _get_core(self):
        _core = []
        runner = self.__get_alias(self._runners[0])
        ssm_state = None
        _th = TaskHandler()
        _last_swc = None
        _is_new_task = False
        _is_new_swc = False
        timer = None


        for x in self._steps:
            match x['kw']:
                case 'g1':
                    ssm_state = x.get('ssm')
                case 'w1':
                    swc = x.get('swc')
                    sgn = x.get('sgn')
                    #Update task
                    c_name, c_order = self._env.get_task(ssm_state, swc)
                    #Check if the current task is a new one
                    _is_new_task = c_name != _th.prev_task
                    _is_new_swc = swc != _last_swc

                    if _is_new_task or _th.order > c_order:
                        _th.update_cursor()

                    new_start, new_cursor = \
                        self._env.get_task_scheduling(c_name, _th.start, _th.cursor)

                    if _is_new_task:
                        _last_swc = None
                        timer = "resume" if timer else '"<b>[T0]"'
                        _core.append(self._get_puml_deactivate_all())
                        if _th.prev_task != None:
                            _core.append(self._get_puml_end_task(
                                task=_th.prev_task,
                                runner=runner,
                            ))
                            self._update_puml_timers(
                                _th.start + self._env.get_task_defs(_th.prev_task)['max_d']
                                )
                        else:
                            _start_time = new_start
                            self._update_puml_timers(_start_time,"Start Time")
                        

                        self._update_puml_timers(new_start)

                        _th.update_task(c_name, c_order, new_start, new_cursor)
                        _core.append(self._get_puml_new_task(
                            task=c_name,
                            timer=timer,
                            runner=runner,
                        ))

                    if _is_new_swc:
                        if _last_swc:
                            _core.append(self._get_puml_deactivation(_last_swc))
                        _core.append(self._get_puml_timer(
                            runner=runner,
                            target=swc,
                            description=f"Call {swc} routine",
                        ))
                        _core.append(self._get_puml_activation(item=swc))
                        _last_swc = swc
                        self._update_puml_timers(self._env.ssm[ssm_state][_th.prev_task][swc])

                    swc_sgn = self._env.get_swc_from_sgn(sgn)
                    _core.append(self._get_puml_read_sgn(swc,swc_sgn,sgn))    
                case 't1':
                    sgn = x.get('sgn')
                    swc_sgn = self._env.get_swc_from_sgn(sgn)
                    _core.append(self._get_puml_write_sgn(_last_swc,swc_sgn,sgn))

        _core.append(self._get_puml_deactivate_all())
        _core.append(self._get_puml_end_task(
            task=c_name,
            runner=runner,
        ))
        self._update_puml_timers(
            value=_th.start + self._env.get_task_defs(_th.prev_task)['max_d'],
            key="End Time")

        return "\n".join(_core)

    def _get_puml_header(self):
        return self.header

    def _get_puml_legend(self):
               
        row1 = "|<b>Time|"
        row2 = "|<b>Value [&#181;s]|"
        
        for k,v in self._puml_timers.items():
            row1 += f" <b>{k} |"
            row2 += f" {v} |"

        return row1+"\n"+row2+"\n"

    def _get_puml_core(self):
        return self._get_core()

def get_existing_path(path: str) -> Path:
    p = Path(path)
    assert p.exists(), 'Error: %s does not exists!' % path
    return p

def get_map(path: str) -> dict:
    p = get_existing_path(path)
    p = yaml.safe_load(p.open('r'))

    #Compile rules
    for k, v in p['g2p'].items():
        t_v = None
        for lbl, rule in v.items():
            t_v = re.compile(rule)
            p['g2p'][k][lbl] = t_v
    
    return p

def get_parsed_step(step: str, rules: dict) -> dict:
    '''Get the standard dictionary representation from a step text'''
    for k,r in rules.items():
        g = r.match(step)
        if g:
            break
    assert g, "Wrong step text syntax:\n\t%s\n\tCorrect syntax rule:\n\t%s" % (step, rules)
    d = dict(g.groupdict())
    d.update({'kw': k})
    return d

def get_collected_steps(scenario: dict, map: dict) -> List[dict]:
    last_keyword: str = None
    res: List[dict] = []

    for step in scenario['steps']:
        last_keyword =  last_keyword if step['keywordType'] == 'Conjunction' else \
            step['keyword'].replace(' ','')
        d = get_parsed_step(step['text'],map[last_keyword])
        res.append(d)

    return res

def main():
    root = Path(__file__).parents[1] 

    gd = Parser().parse("C:/Users/CMM2OFO/Documents/Repos/G2Puml/test_files/demo.feature")
    map = get_map('C:/Users/CMM2OFO/Documents/Repos/G2Puml/src/maps/ad_data_flow.yaml')

    out_f = gd['feature']['children'][0]['scenario']['name']

    elenv = ElopConf(icd_parh=root / "test_files" / 'icd.csv',
                     sch_path='C:/Users/CMM2OFO/Documents/Repos/G2Puml/Strategy2.yaml',
                     ssm_conf_path=root / "test_files" / 'ssm_conf.yaml',
                    )
    steps = get_collected_steps(gd['feature']['children'][0]['scenario'], map['g2p'])

    ad_model = AD_Model(elenv,out_f,steps,out_f)
    ad_model.export_puml()

if __name__ == '__main__':
    main()