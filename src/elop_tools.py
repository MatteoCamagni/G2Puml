import re
import csv
import yaml
from zlib import crc32
from pathlib import Path
from typing import List

SCH_FIELDS = ['start','task','duration']

icd_swc_rgx = re.compile(r"\d+\:\s([\w\s]+)\s\{.*\}")

def get_existing_path(path:str) -> Path:
    p = Path(path)
    assert p.exists(), 'Error: %s does not exists!' % path
    return p

class ElopConf():

    '''Class to handle the ELOP environment'''
    def __init__(self,
                 icd_path: str,
                 sch_path: str,
                 ssm_conf_path: str
                ) -> None:
        self.__icd_path = icd_path
        self.__icdmap, self.__icd  = self.__parse_icd(icd_path)
        self.__sch: List[dict] = self.__parse_sch(sch_path)
        self.__ssm: dict = self.__parse_ssm(ssm_conf_path)
        self.icd_crc: int = self.__get_crc32_from_file(icd_path)
        self.sch_crc: int = self.__get_crc32_from_file(sch_path)
        self.ssm_crc: int = self.__get_crc32_from_file(ssm_conf_path)

    @property
    def icd(self):
         return self.__icd

    @property
    def sch(self):
         return self.__sch

    @property
    def ssm(self):
         return self.__ssm
    
    def __get_crc32_from_file(self, path: str) -> int:
        with get_existing_path(path).open('rb') as f:
            return crc32(f.read())
    
    def __parse_icd(self,path:str) -> List[dict]:
        with get_existing_path(path).open('r') as f:
            r = list(csv.reader(f))
            i= 0
            head = {}
            for h in r.pop(0):
                head.update({h:i})
                i += 1
            i = r.index(['METADATA'])
        return (head, r[0:i-2])
    
    def __parse_sch(self,path:str) -> dict:
        with get_existing_path(path).open('r') as f:
            return next(yaml.safe_load_all(f), None)

    def __parse_ssm(self,path:str) -> dict:
        with get_existing_path(path).open('r') as f:
            return next(yaml.safe_load_all(f), None)
                
    def get_signal(self,sgn: str) -> dict:
        return next(filter(lambda x: x['name'] == sgn, self.__icd), None)
    
    def get_task_scheduling(self, task_name: str, start_time: int = 0, start_pos: int = 0) -> tuple:
        start_time = start_time % self.__sch['defs']['LEW']
        start_pos = start_pos % len(self.__sch['queue'])
        _time_offset = start_time // self.__sch['defs']['LEW']
        for i in range(start_pos, 2*len(self.__sch['queue'])):
            x = self.__sch['queue'][i % len(self.__sch['queue'])]
            if  x[0] >= start_time and x[1] == task_name:
                break
        return (x[0]+_time_offset,i)
            
    def get_task(self, ssm_state: str, ssm_substate:str, swc: str) -> tuple:
        s = self.__ssm[ssm_state][ssm_substate]
        for k,v in s.items():
            if v:
                for m,n in v.items():
                    if m == swc:
                        return (k, n)
        return (None, None)
    
    def get_swc_from_sgn(self,sgn: str) -> str:
        sgn_i = self.__icdmap['Primary Text']
        swc_i = self.__icdmap['Link:SWE.2 - Generated By (<)']
        for x in self.__icd:
            if x[sgn_i] == sgn:
                res = icd_swc_rgx.match(x[swc_i])
                if res:
                    return str(res.group(0))
                raise Exception('The signal %s does not have a related SWC in ICD (%s)' % (sgn,self.__icd_path))
        raise Exception('The signal %s is not defined in ICD (%s)' % (sgn,self.__icd_path))
    
    def get_task_defs(self,task: str) -> dict:
        res = self.__sch['defs']['tasks']
        res = res.get(task)
        return res